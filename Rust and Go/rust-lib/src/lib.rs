// Используем `libc` для работы с C-типами, но для базовых примеров можно и без него.
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

// Функция для сложения двух чисел.
// #[no_mangle] отключает "mangling" имён - гарантирует, что символ в библиотеке
// будет называться именно `add_numbers`, а не как-то сложно.
// extern "C" указывает, что функция использует C calling convention.
#[no_mangle]
pub extern "C" fn add_numbers(a: i32, b: i32) -> i32 {
    a + b
}

// Функция для работы со строками. Более сложный и реалистичный пример.
// ВНИМАНИЕ: Управление памятью при работе со строками через FFI критически важно.
// Правило: кто выделил память, тот и должен её освободить.
//
// Эта функция принимает C-строку (*const c_char), конвертирует её в Rust строку,
// что-то делает (здесь - делает её uppercase) и возвращает новую C-строку.
// Память для новой строки выделяется в Rust с помощью CString, и указатель на неё
// передается наружу. Освобождать её должен вызывающий (в нашем случае - Go) с помощью
// специальной функции `free_rust_memory`.
#[no_mangle]
pub extern "C" fn make_uppercase(s: *const c_char) -> *mut c_char {
    // Безопасно преобразуем C-строку в Rust-строку. panic если что-то не так.
    let c_str = unsafe { CStr::from_ptr(s) };
    let rust_str = c_str.to_str().expect("Failed to convert to Rust str");

    // Преобразуем в верхний регистр
    let uppercased = rust_str.to_uppercase();

    // Создаем новую C-строку из Rust строки. into_raw() передает владение памятью "наружу".
    CString::new(uppercased).unwrap().into_raw()
}

// Функция для ОСВОБОЖДЕНИЯ памяти, которую выделил Rust.
// Эту функцию ДОЛЖЕН вызвать Go после того, как закончит работу со строкой.
// Мы должны снова получить владение указателем, чтобы корректно его освободить.
#[no_mangle]
pub extern "C" fn free_rust_memory(ptr: *mut c_char) {
    // Превращаем raw pointer обратно в CString, чтобы его деструктор вызвался
    // и освободил память. Это безопасно только если эта память была действительно
    // выделена с помощью `CString::into_raw`.
    if ptr.is_null() {
        return;
    }
    unsafe { CString::from_raw(ptr) };
}